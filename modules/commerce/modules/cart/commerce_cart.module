<?php

/**
 * @file
 * Implements the shopping cart system and add to cart features.
 *
 * In Drupal Commerce, the shopping cart is really just an order that makes
 * special considerations to associate it with a user and
 */


/**
 * Implements hook_menu().
 */
function commerce_cart_menu() {
  $items = array();

  $items['cart'] = array(
    'title' => 'Shopping cart',
    'page callback' => 'commerce_cart_view',
    'access arguments' => array('access content'),
    'file' => 'includes/commerce_cart.pages.inc',
  );

  $items['cart/my'] = array(
    'title' => 'Shopping cart (# items)',
    'title callback' => 'commerce_cart_menu_item_title',
    'title arguments' => array(TRUE),
    'page callback' => 'drupal_goto',
    'page arguments' => array('cart'),
    'access arguments' => array('access content'),
    'type' => MENU_SUGGESTED_ITEM,
  );

  $items['checkout'] = array(
    'title' => 'Checkout',
    'page callback' => 'commerce_cart_checkout_router',
    'access arguments' => array('access checkout'),
    'type' => MENU_CALLBACK,
    'file' => 'includes/commerce_cart.pages.inc',
  );

  return $items;
}

/**
 * Returns the title of the shopping cart menu item with an item count.
 */
function commerce_cart_menu_item_title() {
  global $user;

  // Load the current user's cart order.
  $order = commerce_cart_order_load($user->uid);

  // If it's empty or has no line items, return a static title.
  if (empty($order) || empty($order->commerce_line_items)) {
    return t('Shopping cart');
  }

  // Count the number of product line items on the order.
  $wrapper = entity_metadata_wrapper('commerce_order', $order);
  $quantity = commerce_line_items_quantity($wrapper->commerce_line_items, 'product');

  // Return the title with an item count appended.
  return format_plural($quantity, 'Shopping cart (1 item)', 'Shopping cart (@count items)');
}

/**
 * Implements hook_commerce_order_state_info().
 */
function commerce_cart_commerce_order_state_info() {
  $order_states = array();

  $order_states['cart'] = array(
    'name' => 'cart',
    'title' => t('Shopping cart'),
    'description' => t('Orders in this state have not been completed by the customer yet.'),
    'weight' => -5,
    'default_status' => 'cart',
  );

  return $order_states;
}

/**
 * Implements hook_commerce_order_status_info().
 */
function commerce_cart_commerce_order_status_info() {
  $order_statuses = array();

  $order_statuses['cart'] = array(
    'name' => 'cart',
    'title' => t('Shopping cart'),
    'state' => 'cart',
    'cart' => TRUE,
  );

  return $order_statuses;
}

/**
 * Implements hook_commerce_checkout_pane_info().
 */
function commerce_cart_commerce_checkout_pane_info() {
  $checkout_panes = array();

  $checkout_panes['cart_contents'] = array(
    'title' => t('Shopping cart contents'),
    'base' => 'commerce_cart_contents_pane',
    'file' => 'includes/commerce_cart.checkout_pane.inc',
    'page' => 'checkout',
    'weight' => -10,
  );

  return $checkout_panes;
}

/**
 * Implements hook_commerce_checkout_complete().
 */
function commerce_cart_commerce_checkout_complete($order) {
  // Move the cart order ID to a completed order ID.
  if (commerce_cart_order_session_exists($order->order_id)) {
    commerce_cart_order_session_save($order->order_id, TRUE);
    commerce_cart_order_session_delete($order->order_id);
  }
}

/**
 * Implements hook_commerce_line_item_summary_link_info().
 */
function commerce_cart_commerce_line_item_summary_link_info() {
  return array(
    'view_cart' => array(
      'title' => t('View cart'),
      'href' => 'cart',
      'attributes' => array('rel' => 'nofollow'),
      'weight' => 0,
    ),
    'checkout' => array(
      'title' => t('Checkout'),
      'href' => 'checkout',
      'attributes' => array('rel' => 'nofollow'),
      'weight' => 5,
      'access' => user_access('access checkout'),
    ),
  );
}

/**
 * Implements hook_form_alter().
 */
function commerce_cart_form_alter(&$form, &$form_state, $form_id) {
  if (strpos($form_id, 'commerce_line_item_views_form_commerce_cart_form_') === 0) {
    // Change the Save button to say Update cart.
    $form['actions']['update']['#value'] = t('Update cart');
    $form['actions']['update']['#submit'] = array_merge($form['#submit'], array('commerce_cart_line_item_views_form_submit'));

    // Change any Delete buttons to say Remove.
    if (!empty($form['edit_delete'])) {
      foreach(element_children($form['edit_delete']) as $line_item_id) {
        // Load and wrap the line item to have the title in the submit phase.
        $form_state['line_items'][$line_item_id] = commerce_line_item_load($line_item_id);
        $form['edit_delete'][$line_item_id]['#value'] = t('Remove');
        $form['edit_delete'][$line_item_id]['#submit'] = array_merge($form['#submit'], array('commerce_cart_line_item_delete_form_submit'));
      }
    }
  }
  elseif (strpos($form_id, 'commerce_checkout_form_') === 0 && !empty($form['buttons']['cancel'])) {
    // Override the submit handler for changing the order status on checkout cancel.
    foreach ($form['buttons']['cancel']['#submit'] as $key => &$value) {
      if ($value == 'commerce_checkout_form_cancel_submit') {
        $value = 'commerce_cart_checkout_form_cancel_submit';
      }
    }
  }
}

/**
 * Submit handler to take back the order to cart status on cancel in checkout.
 */
function commerce_cart_checkout_form_cancel_submit($form, &$form_state) {
  // Update the order to the cart status.
  $order = commerce_order_load($form_state['order']->order_id);
  $form_state['order'] = commerce_order_status_update($order, 'cart', TRUE);

  // Skip saving in the status update and manually save here to force a save
  // even when the status doesn't actually change.
  $form_state['order']->revision = TRUE;
  $form_state['order']->log = t('Customer manually canceled the checkout process.');

  commerce_order_save($form_state['order']);

  drupal_set_message(t('Checkout of your current order has been canceled and may be resumed when you are ready.'));

  // Redirect to cart on cancel.
  $form_state['redirect'] = 'cart';
}

/**
 * Submit handler to show the shopping cart updated message.
 */
function commerce_cart_line_item_views_form_submit($form, &$form_state) {
  // Reset the status of the order to cart.
  $order = commerce_order_load($form_state['order']->order_id);
  $form_state['order'] = commerce_order_status_update($order, 'cart', TRUE);

  // Skip saving in the status update and manually save here to force a save
  // even when the status doesn't actually change.
  $form_state['order']->revision = TRUE;
  $form_state['order']->log = t('Customer updated the order via the shopping cart form.');

  commerce_order_save($form_state['order']);

  drupal_set_message(t('Your shopping cart has been updated.'));
}

/**
 * Submit handler to show the line item delete message.
 */
function commerce_cart_line_item_delete_form_submit($form, &$form_state) {
  // Get which delete button has been clicked.
  $line_item_id = substr($form_state['clicked_button']['#name'], strlen('delete-line-item-'));

  // Get the corresponding wrapper to show the correct title.
  $line_item_wrapper = entity_metadata_wrapper('commerce_line_item', $form_state['line_items'][$line_item_id]);

  // If the deleted line item is a product...
  if ($line_item_wrapper->type->value() == 'product') {
    $title = $line_item_wrapper->commerce_product->title->value();

    // Invoke the Rules event for removing an item from the cart so the order
    // status can be reset by the default rule.
    rules_invoke_all('commerce_cart_product_remove', $form_state['order'], $line_item_wrapper->commerce_product->value(), $line_item_wrapper->quantity->value(), $line_item_wrapper->value());
  }
  else {
    $title = $line_item_wrapper->line_item_label->value();
  }

  drupal_set_message(t('%title removed from your cart.', array('%title' => $title)));
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Alter the order edit form so administrators cannot attempt to alter line item
 * unit prices for orders still in a shopping cart status. On order load, the
 * cart module refreshes these prices based on the current product price and
 * pricing rules, so any alterations would not be persistent anyways.
 *
 * @see commerce_cart_commerce_order_load()
 */
function commerce_cart_form_commerce_order_ui_order_form_alter(&$form, &$form_state) {
  $order = $form_state['commerce_order'];

  // If the order being edited is in a shopping cart status...
  if (commerce_cart_order_is_cart($order)) {
    // Loop over the line items on the form...
    foreach ($form['commerce_line_items'][$form['commerce_line_items']['#language']]['line_items'] as &$line_item) {
      // Disable the unit price amount and currency code fields.
      $language = $line_item['commerce_unit_price']['#language'];
      $line_item['commerce_unit_price'][$language][0]['amount']['#disabled'] = TRUE;
      $line_item['commerce_unit_price'][$language][0]['currency_code']['#disabled'] = TRUE;
    }
  }
}

/**
 * Implements hook_commerce_order_delete().
 */
function commerce_cart_commerce_order_delete($order) {
  commerce_cart_order_session_delete($order->order_id);
  commerce_cart_order_session_delete($order->order_id, TRUE);
}

/**
 * Implements hook_views_api().
 */
function commerce_cart_views_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'commerce_cart') . '/includes/views',
  );
}

/**
 * Implements hook_theme().
 */
function commerce_cart_theme() {
  return array(
    'commerce_cart_empty_block' => array(
      'variables' => array(),
    ),
    'commerce_cart_empty_page' => array(
      'variables' => array(),
    ),
    'commerce_cart_block' => array(
      'variables' => array('order' => NULL, 'contents_view' => NULL),
      'path' => drupal_get_path('module', 'commerce_cart') . '/theme',
      'template' => 'commerce-cart-block',
    ),
  );
}

/**
 * Implements hook_user_login().
 *
 * When a user logs into the site, if they have a shopping cart order it should
 * be updated to belong to their user account.
 */
function commerce_cart_user_login(&$edit, $account) {
  // Get the user's anonymous shopping cart order if it exists.
  if ($order = commerce_cart_order_load()) {
    // Convert it to an authenticated cart.
    commerce_cart_order_convert($order, $account);
  }
}

/**
 * Implements hook_block_info().
 */
function commerce_cart_block_info() {
  $blocks = array();

  // Define the basic shopping cart block and hide it on the checkout pages.
  $blocks['cart'] = array(
    'info' => t('Shopping cart'),
    'cache' => DRUPAL_NO_CACHE,
    'visibility' => 0,
    'pages' => 'checkout*',
  );

  return $blocks;
}

/**
 * Implements hook_block_view().
 */
function commerce_cart_block_view($delta) {
  global $user;

  // Prepare the display of the default Shopping Cart block.
  if ($delta == 'cart') {
    // First check for items in the shopping cart.
    $order = commerce_cart_order_load($user->uid);

    // If the cart is empty...
    if (!$order || empty($order->commerce_line_items)) {
      // Display an appropriate message.
      $content = theme('commerce_cart_empty_block');
    }
    else {
      drupal_add_css(drupal_get_path('module', 'commerce_cart') . '/theme/commerce_cart.css');

      // Build the variables array to send to the cart block template.
      $variables = array(
        'order' => $order,
        'contents_view' => commerce_embed_view('commerce_cart_block', 'defaults', array($order->order_id)),
      );

      $content = theme('commerce_cart_block', $variables);
    }

    return array('subject' => t('Shopping cart'), 'content' => $content);
  }
}

/**
 * Implements hook_commerce_order_load().
 *
 * Because shopping carts are merely a special case of orders, we work through
 * the Order API to ensure that products in shopping carts are kept up to date.
 * Therefore, each time a cart is loaded, we calculate afresh the unit and total
 * prices of product line items and save them if any values have changed.
 */
function commerce_cart_commerce_order_load($orders) {
  static $refreshed = array();

  foreach ($orders as $order) {
    // Refresh only if this order hasn't been refreshed already.
    if (!in_array($order->order_id, $refreshed) &&
      commerce_cart_order_is_cart($order)) {
      // Refresh the order and add its ID to the refreshed array.
      commerce_cart_order_refresh($order);
      $refreshed[] = $order->order_id;
    }
  }
}

/**
 * Themes an empty shopping cart block's contents.
 */
function theme_commerce_cart_empty_block() {
  return '<div class="cart-empty-block">' . t('Your shopping cart is empty.') . '</div>';
}

/**
 * Themes an empty shopping cart page.
 */
function theme_commerce_cart_empty_page() {
  return '<div class="cart-empty-page">' . t('Your shopping cart is empty.') . '</div>';
}

/**
 * Loads the shopping cart order for the specified user.
 *
 * @param $uid
 *   The uid of the customer whose cart to load. If left 0, attempts to load
 *     an anonymous order from the session.
 *
 * @return
 *   The fully loaded shopping cart order or FALSE if non-existent.
 */
function commerce_cart_order_load($uid = 0) {
  // Cart order IDs will be cached keyed by $uid.
  $cart_order_ids = &drupal_static(__FUNCTION__);

  // Cache the user's cart order ID if it hasn't been set already.
  if (!isset($cart_order_ids[$uid])) {
    // Create an array of valid shopping cart order statuses.
    $status_ids = array_keys(commerce_order_statuses(array('cart' => TRUE)));

    // If a customer uid was specified...
    if ($uid) {
      // Look for the user's most recent shopping cart order, although they
      // should never really have more than one.
      $cart_order_ids[$uid] = db_query('SELECT order_id FROM {commerce_order} WHERE uid = :uid AND status IN (:status_ids) ORDER BY order_id DESC', array(':uid' => $uid, ':status_ids' => $status_ids))->fetchField();
    }
    else {
      // Otherwise look for a shopping cart order ID in the session.
      if (commerce_cart_order_session_exists()) {
        // We can't trust a user's session to contain only their order IDs, as
        // they could've edited their session to try and gain access to someone
        // else's order data. Therefore, this query restricts its search to
        // orders assigned to anonymous users using the same IP address to try
        // and mitigate risk as much as possible.
        $cart_order_ids[$uid] = db_query('SELECT order_id FROM {commerce_order} WHERE order_id IN (:order_ids) AND uid = 0 AND hostname = :hostname AND status IN (:status_ids) ORDER BY order_id DESC', array(':order_ids' => commerce_cart_order_session_order_ids(), ':hostname' => ip_address(), ':status_ids' => $status_ids))->fetchField();
      }
    }
  }

  // If a valid cart order ID exists for the user, return it now.
  if (!empty($cart_order_ids[$uid])) {
    return commerce_order_load($cart_order_ids[$uid]);
  }

  return FALSE;
}

/**
 * Resets the cached array of shopping cart orders.
 */
function commerce_cart_orders_reset() {
  $cart_orders = &drupal_static('commerce_cart_order_load');
  $cart_orders = NULL;
}

/**
 * Creates a new shopping cart order for the specified user.
 *
 * @param $uid
 *   The uid of the user for whom to create the order. If left 0, the order will
 *     be created for the current user and associated with his or her session.
 *
 * @return
 *   The newly created shopping cart order object.
 */
function commerce_cart_order_new($uid = 0) {
  // Create the new order with the customer's uid and the cart order status.
  $order = commerce_order_new($uid, 'cart');
  $order->log = t('Created as a shopping cart order.');

  // Save it so it gets an order ID and return the full object.
  $order = commerce_order_save($order);

  // Reset the cart cache
  commerce_cart_orders_reset();

  // If the user is not logged in, ensure the order ID is stored in the session.
  if (!$uid) {
    commerce_cart_order_session_save($order->order_id);
  }

  return $order;
}

/**
 * Determines whether or not the given order is a shopping cart order.
 */
function commerce_cart_order_is_cart($order) {
  // If the order is in a shopping cart order status, assume it is a cart.
  $is_cart = in_array($order->status, array_keys(commerce_order_statuses(array('cart' => TRUE))));

  // Allow other modules to make the judgment based on some other criteria.
  if (in_array(FALSE, module_invoke_all('commerce_cart_order_is_cart', $order, $is_cart))) {
    $is_cart = FALSE;
  }

  return $is_cart;
}

/**
 * Converts an anonymous shopping cart order to an authenticated cart.
 *
 * @param $order
 *   The anonymous order to convert to an authenticated cart.
 * @param $account
 *   The user account the order will belong to.
 *
 * @return
 *   The updated order's wrapper or FALSE if the order was not converted,
 *     meaning it was not an anonymous cart order to begin with.
 */
function commerce_cart_order_convert($order, $account) {
  // Only convert orders that are currently anonmyous orders.
  if ($order->uid == 0) {
    // Update the uid and e-mail address to match the current account since
    // there currently is no way to specify a custom e-mail address per order.
    $order->uid = $account->uid;
    $order->mail = $account->mail;

    // Update the uid of any referenced customer profiles.
    $order_wrapper = entity_metadata_wrapper('commerce_order', $order);

    foreach (commerce_customer_profile_types() as $type => $profile_type) {
      $field_name = 'commerce_customer_' . $type;

      if (!is_null($order_wrapper->{$field_name}->value()) &&
        $order_wrapper->{$field_name}->uid->value() == 0) {
        $order_wrapper->{$field_name}->uid = $account->uid;
        $order_wrapper->{$field_name}->save();
      }
    }

    // Allow other modules to operate on the converted order and then save.
    module_invoke_all('commerce_cart_order_convert', $order_wrapper, $account);
    $order_wrapper->save();

    return $order_wrapper;
  }

  return FALSE;
}

/**
 * Refreshes the contents of a shopping cart by finding the most current prices
 *   for any product line items on the order.
 *
 * @param $order
 *   The order object whose line items should be refreshed.
 *
 * @return
 *   The updated order's wrapper.
 */
function commerce_cart_order_refresh($order) {
  $order_wrapper = entity_metadata_wrapper('commerce_order', $order);

  // Loop over every line item on the order...
  $line_item_changed = FALSE;

  foreach ($order_wrapper->commerce_line_items as $delta => $line_item_wrapper) {
    $line_item = clone($line_item_wrapper->value());

    // If the line item is a product line item...
    if ($line_item->type == 'product') {
      // Load the product unchanged from the database so any existing price
      // adjustments aren't duplicated in this line item.
      $product = entity_load_unchanged('commerce_product', $line_item_wrapper->commerce_product->product_id->value());

      // Repopulate the line item array with the default values for the product
      // as though it had not been added to the cart yet, but preserve the
      // current quantity and display URI information.
      commerce_product_line_item_populate($line_item, $product, $line_item->quantity, empty($line_item->data['display_uri']) ? NULL : $line_item->data['display_uri']);

      // Process the unit price through Rules so it reflects the user's actual
      // current purchase price.
      rules_invoke_event('commerce_product_calculate_sell_price', $line_item);
    }

    // Allow other modules alter line items on a shopping cart refresh.
    module_invoke_all('commerce_cart_line_item_refresh', $line_item, $order_wrapper);

    // Compare the refreshed unit price to the original unit price looking for
    // differences in the amount, currency code, or price components.
    $current_line_item_wrapper = entity_metadata_wrapper('commerce_line_item', $line_item);
    $data = $line_item_wrapper->commerce_unit_price->data->value();
    $current_data = $current_line_item_wrapper->commerce_unit_price->data->value();

    if ($line_item_wrapper->commerce_unit_price->amount->value() != $current_line_item_wrapper->commerce_unit_price->amount->value() ||
      $line_item_wrapper->commerce_unit_price->currency_code->value() != $current_line_item_wrapper->commerce_unit_price->currency_code->value() ||
      $data['components'] != $current_data['components']) {
      // Adjust the unit price accordingly if necessary.
      $line_item_wrapper->commerce_unit_price->amount = $current_line_item_wrapper->commerce_unit_price->amount->value();
      $line_item_wrapper->commerce_unit_price->currency_code = $current_line_item_wrapper->commerce_unit_price->currency_code->value();

      // Only migrate the price components in the data to preserve other data.
      $data['components'] = $current_data['components'];
      $line_item_wrapper->commerce_unit_price->data = $data;

      // Save the updated line item and clear the entity cache.
      commerce_line_item_save($line_item_wrapper->value());
      entity_get_controller('commerce_line_item')->resetCache(array($line_item_wrapper->line_item_id->value()));

      $line_item_changed = TRUE;
    }
  }

  // Store a copy of the original order to see if it changes later.
  $original_order = clone($order_wrapper->value());

  // Allow other modules to alter the entire order on a shopping cart refresh.
  module_invoke_all('commerce_cart_order_refresh', $order_wrapper);

  // Save the order once here if it has changed or if a line item was changed.
  if ($order_wrapper->value() != $original_order || $line_item_changed) {
    commerce_order_save($order_wrapper->value());
  }

  return $order_wrapper;
}

/**
 * Entity metadata callback: returns the current user's shopping cart order.
 *
 * @see commerce_cart_entity_property_info_alter()
 */
function commerce_cart_get_properties($data = FALSE, array $options, $name) {
  global $user;

  switch ($name) {
    case 'current_cart_order':
      if ($order = commerce_cart_order_load($user->uid)) {
        return $order;
      }
      else {
        return commerce_order_new($user->uid, 'cart');
      }
  }
}

/**
 * Returns an array of cart order IDs stored in the session.
 *
 * @param $completed
 *   Boolean indicating whether or not the operation should save to the
 *     completed orders array instead of the active cart orders array.
 *
 * @return
 *   An array of applicable cart order IDs or an empty array if none exist.
 */
function commerce_cart_order_session_order_ids($completed = FALSE) {
  $key = $completed ? 'commerce_cart_completed_orders' : 'commerce_cart_orders';
  return empty($_SESSION[$key]) ? array() : $_SESSION[$key];
}

/**
 * Saves an order ID to the appropriate cart orders session variable.
 *
 * @param $order_id
 *   The order ID to save to the array.
 * @param $completed
 *   Boolean indicating whether or not the operation should save to the
 *     completed orders array instead of the active cart orders array.
 */
function commerce_cart_order_session_save($order_id, $completed = FALSE) {
  $key = $completed ? 'commerce_cart_completed_orders' : 'commerce_cart_orders';

  if (empty($_SESSION[$key])) {
    $_SESSION[$key] = array($order_id);
  }
  elseif (!in_array($order_id, $_SESSION[$key])) {
    $_SESSION[$key][] = $order_id;
  }
}

/**
 * Checks to see if any order ID or a specific order ID exists in the session.
 *
 * @param $order_id
 *   Optionally specify an order ID to look for in the commerce_cart_orders
 *     session variable; defaults to NULL.
 * @param $completed
 *   Boolean indicating whether or not the operation should look in the
 *     completed orders array instead of the active cart orders array.
 *
 * @return
 *   Boolean indicating whether or not any cart order ID exists in the session
 *     or if the specified order ID exists in the session.
 */
function commerce_cart_order_session_exists($order_id = NULL, $completed = FALSE) {
  $key = $completed ? 'commerce_cart_completed_orders' : 'commerce_cart_orders';

  // If an order was specified, look for it in the array.
  if (!empty($order_id)) {
    return !empty($_SESSION[$key]) && in_array($order_id, $_SESSION[$key]);
  }
  else {
    // Otherwise look for any value.
    return !empty($_SESSION[$key]);
  }
}

/**
 * Deletes all order IDs or a specific order ID from the cart orders session
 *   variable.
 *
 * @param $order_id
 *   The order ID to remove from the array or NULL to delete the variable.
 * @param $completed
 *   Boolean indicating whether or not the operation should delete from the
 *     completed orders array instead of the active cart orders array.
 */
function commerce_cart_order_session_delete($order_id = NULL, $completed = FALSE) {
  $key = $completed ? 'commerce_cart_completed_orders' : 'commerce_cart_orders';

  if (!empty($_SESSION[$key])) {
    if (!empty($order_id)) {
      $_SESSION[$key] = array_diff($_SESSION[$key], array($order_id));
    }
    else {
      unset($_SESSION[$key]);
    }
  }
}

/**
 * Adds the specified product to a customer's shopping cart.
 *
 * @param $uid
 *   The uid of the user whose cart you are adding the product to.
 * @param $product_id
 *   The ID of the product to add to the cart.
 * @param $quantity
 *   The quantity of this product to add to the cart.
 * @param $display_uri
 *   A URI array as returned by entity_uri() indicating the display to link the
 *     product line item to; defaults to NULL for no display.
 *
 * @return
 *   The new or updated line item object or FALSE on failure.
 */
function commerce_cart_product_add($uid, $product_id, $quantity, $display_uri = NULL) {
  // Load and validate the specified product ID.
  $product = commerce_product_load($product_id);

  // Fail if the product does not exist or is disabled.
  if (empty($product) || !$product->status) {
    return FALSE;
  }

  // First attempt to load the customer's shopping cart order.
  $order = commerce_cart_order_load($uid);

  // If no order existed, create one now.
  if (empty($order)) {
    $order = commerce_cart_order_new($uid);
  }

  // Wrap the order for easy access to field data.
  $order_wrapper = entity_metadata_wrapper('commerce_order', $order);

  // Invoke the product prepare event with the shopping cart order.
  rules_invoke_all('commerce_cart_product_prepare', $order, $product, $quantity);

  // Determine if the product already exists on the order and increment its
  // quantity instead of adding a new line if it does.
  $line_item = NULL;

  // Loop through the line items looking for products.
  foreach ($order_wrapper->commerce_line_items as $delta => $line_item_wrapper) {
    // If this line item matches the product being added...
    if (empty($line_item) &&
        $line_item_wrapper->type->value() == 'product' &&
        $line_item_wrapper->commerce_product->product_id->value() == $product_id) {
      // Exit this loop with the $line_item intact so it gets updated.
      $line_item = $line_item_wrapper->value();
    }
  }

  // If no matching line item was found...
  if (empty($line_item)) {
    // Create the new product line item.
    $line_item = commerce_product_line_item_new($product, $quantity, $order->order_id, $display_uri);

    // Process the unit price through Rules so it reflects the user's actual
    // purchase price.
    rules_invoke_event('commerce_product_calculate_sell_price', $line_item);

    // Save the line item now so we get its ID.
    $line_item = commerce_line_item_save($line_item);

    // Add it to the order's line item reference value.
    $order_wrapper->commerce_line_items[] = $line_item;
  }
  else {
    // Increment the quantity of the line item and save it.
    $line_item->quantity += $quantity;
    commerce_line_item_save($line_item);

    // Clear the line item cache so the updated quantity will be available to
    // the ensuing load instead of the original quantity as loaded above.
    entity_get_controller('commerce_line_item')->resetCache(array($line_item->line_item_id));
  }

  // Save the updated order.
  commerce_order_save($order);

  // Invoke the product add event with the newly saved or updated line item.
  rules_invoke_all('commerce_cart_product_add', $order, $product, $quantity, $line_item);

  // Return the line item.
  return $line_item;
}

/**
 * Deletes a product line item from a shopping cart order.
 *
 * @param $order
 *   The shopping cart order to delete from.
 * @param $line_item_id
 *   The ID of the product line item to delete from the order.
 * @param $skip_save
 *   TRUE to skip saving the order after deleting the line item; used when the
 *     order would otherwise be saved or to delete multiple product line items
 *     from the order and then save.
 *
 * @return
 *   The order with the matching product line item deleted from the line item
 *     reference field.
 */
function commerce_cart_order_product_line_item_delete($order, $line_item_id, $skip_save = FALSE) {
  $line_item = commerce_line_item_load($line_item_id);

  // Check to ensure the line item exists and is a product line item.
  if (!$line_item || $line_item->type != 'product') {
    return $order;
  }

  // Remove the line item from the line item reference field.
  $order = commerce_entity_reference_delete('commerce_order', $order, 'commerce_line_items', $line_item_id);

  // Wrap the line item to be deleted and extract the product from it.
  $wrapper = entity_metadata_wrapper('commerce_line_item', $line_item);
  $product = $wrapper->commerce_product->value();

  // Invoke the product removal event with the line item about to be deleted.
  rules_invoke_all('commerce_cart_product_remove', $order, $product, $line_item->quantity, $line_item);

  // Delete the actual line item.
  commerce_line_item_delete($line_item->line_item_id);

  return $skip_save ? $order : commerce_order_save($order);
}

/**
 * Deletes every product line item from a shopping cart order.
 *
 * @param $order
 *   The shopping cart order to empty.
 *
 * @return
 *   The order with the product line items all removed.
 */
function commerce_cart_order_empty($order) {
  $order_wrapper = entity_metadata_wrapper('commerce_order', $order);

  // Build an array of product line item IDs.
  $line_item_ids = array();

  foreach ($order_wrapper->commerce_line_items as $delta => $line_item_wrapper) {
    if ($line_item_wrapper->type->value() == 'product') {
      $line_item_ids[] = $line_item_wrapper->line_item_id->value();
    }
  }

  // Delete each line item one by one from the order. This is done this way
  // instead of unsetting each as we find it to ensure that changing delta
  // values don't prevent an item from being removed from the order.
  foreach ($line_item_ids as $line_item_id) {
    $order = commerce_cart_order_product_line_item_delete($order, $line_item_id, TRUE);
  }

  return commerce_order_save($order);
}

/**
 * Builds an appropriate cart form ID based on the products on the form.
 *
 * @see commerce_cart_forms().
 */
function commerce_cart_add_to_cart_form_id($product_ids, $qty = 0) {
  // Make sure the length of the form id is limited.
  $data = implode('_', $product_ids);

  if (strlen($data) > 50) {
    $data = drupal_hash_base64($data);
  }

  return 'commerce_cart_add_to_cart_form_' . $data;
}

/**
 * Implements hook_forms().
 *
 * To provide distinct form IDs for add to cart forms, the product IDs
 * referenced by the form are appended to the base ID,
 * commerce_cart_add_to_cart_form. When such a form is built or submitted, this
 * function will return the proper callback function to use for the given form.
 */
function commerce_cart_forms($form_id, $args) {
  $forms = array();

  // Construct a valid cart form ID from the arguments.
  if (strpos($form_id, 'commerce_cart_add_to_cart_form_') === 0) {
    $forms[$form_id] = array(
      'callback' => 'commerce_cart_add_to_cart_form',
    );
  }

  return $forms;
}

/**
 * Builds an Add to Cart form for a set of products.
 *
 * @param $product_ids
 *   An array of product IDs that will be included in the form.
 * @param $show_quantity
 *   Boolean indicating whether or not the quantity field should be shown;
 *     defaults to FALSE resulting in a hidden field.
 * @param $default_quantity
 *   The value to place in the quantity field, defaults to 1.
 * @param $context
 *   Information on the context of the form's placement, allowing it to update
 *     product fields on the page based on the currently selected default
 *     product. Should be an associative array containing the following keys:
 *     - class_prefix: a prefix used to target HTML containers for replacement
 *       with rendered fields as the default product is updated. For example,
 *       nodes display product fields in their context wrapped in spans with the
 *       class node-#-product-field_name.  The class_prefix for the add to cart
 *       form displayed on a node would be node-# with this form's AJAX refresh
 *       adding the suffix -product-field_name.
 *     - view_mode: a product view mode that tells the AJAX refresh how to
 *       render the replacement fields.
 *     If no context is specified, AJAX replacement of rendered fields will not
 *     happen. This parameter only affects forms containing multiple products.
 * @param $display_uri
 *   A URI array as returned by entity_uri() indicating the display to link the
 *     product line item to; defaults to NULL for no display.
 *
 * @return
 *   The form array.
 */
function commerce_cart_add_to_cart_form($form, &$form_state, $product_ids, $show_quantity = FALSE, $default_quantity = 1, $context = array(), $display_uri = NULL) {
  global $user;

  // Store the form ID as a class of the form to avoid the incrementing form ID
  // from causing the AJAX refresh not to work.
  $form['#attributes']['class'][] = drupal_html_class(commerce_cart_add_to_cart_form_id($product_ids, $default_quantity));

  // Store the customer uid in the form so other modules can override with a
  // selection widget if necessary.
  $form['uid'] = array(
    '#type' => 'value',
    '#value' => $user->uid,
  );

  // Load all the products intended for sale on this form.
  $products = commerce_product_load_multiple($product_ids, array('status' => 1));

  // If no products were returned...
  if (count($products) == 0) {
    $form['submit'] = array(
      '#type' => 'submit',
      '#value' => t('Product not available'),
      '#disabled' => TRUE,
    );
  }
  else {
    $form_state['products'] = $products;

    // If the form is for a single product, store the product_id in a hidden
    // form field for use by the submit handler.
    if (count($products) == 1) {
      $form['product_id'] = array(
        '#type' => 'hidden',
        '#value' => key($products),
      );
    }
    else {
      // However, if more than one products are represented on it, attempt to
      // use smart select boxes for the product selection. If the products are
      // all of the same type and there are qualifying fields on that product
      // type, display their options for customer selection.
      $same_type = TRUE;
      $qualifying_fields = array();
      $type = '';

      // Find the default product so we know how to set default options on the
      // various Add to Cart form widgets and an array of any matching product
      // based on attribute selections so we can add a selection widget.
      $matching_products = array();
      $default_product = NULL;
      $attribute_names = array();
      $unchanged_attributes = array();

      foreach ($products as $product_id => $product) {
        $product_wrapper = entity_metadata_wrapper('commerce_product', $product);

        // Store the first product type.
        if (empty($type)) {
          $type = $product->type;
        }

        // If the current product type is different from the first, we are not
        // dealing with a set of same typed products.
        if ($product->type != $type) {
          $same_type = FALSE;
        }

        // If the form state contains a set of attribute data, use it to try
        // and determine the default product.
        $changed_attribute = NULL;

        if (!empty($form_state['values']['attributes'])) {
          $match = TRUE;

          // Set an array of checked attributes for later comparison against the
          // default matching product.
          if (empty($attribute_names)) {
            $attribute_names = (array) array_diff_key($form_state['values']['attributes'], array('product_select' => ''));
            $unchanged_attributes = $form_state['values']['unchanged_attributes'];
          }

          foreach ($attribute_names as $key => $value) {
            // If this is the attribute widget that was changed...
            if ($value != $unchanged_attributes[$key]) {
              // Store the field name.
              $changed_attribute = $key;
            }

            // If a field name has been stored and we've moved past it to
            // compare the next attribute field...
            if (!empty($changed_attribute) && $changed_attribute != $key) {
              // Wipe subsequent values from the form state so the attribute
              // widgets can use the default values from the new default product.
              unset($form_state['input']['attributes'][$key]);

              // Don't accept this as a matching product.
              continue;
            }

            if ($product_wrapper->{$key}->value() != $value) {
              $match = FALSE;
            }
          }

          // If the changed field name has already been stored, only accept the
          // first matching product by ignoring the rest that would match. An
          // exception is granted for additional matching products that share
          // the exact same attribute values as the first.
          if ($match && !empty($changed_attribute) && !empty($matching_products)) {
            reset($matching_products);
            $matching_product = $matching_products[key($matching_products)];
            $matching_product_wrapper = entity_metadata_wrapper('commerce_product', $matching_product);

            foreach ($attribute_names as $key => $value) {
              if ($product_wrapper->{$key}->value() != $matching_product_wrapper->{$key}->value()) {
                $match = FALSE;
              }
            }
          }

          if ($match) {
            $matching_products[$product_id] = $product;
          }
        }
      }

      // Set the default product now if it isn't already set.
      if (empty($matching_products)) {
        // If a product ID value was passed in, use that product if it exists.
        if (!empty($form_state['values']['product_id']) &&
            !empty($products[$form_state['values']['product_id']])) {
          $default_product = $products[$form_state['values']['product_id']];
        }
        else {
          reset($products);
          $default_product = $products[key($products)];
        }
      }
      else {
        // If the product selector has a value, use that.
        if (!empty($form_state['values']['attributes']['product_select']) &&
            !empty($products[$form_state['values']['attributes']['product_select']]) &&
            in_array($products[$form_state['values']['attributes']['product_select']], $matching_products)) {
          $default_product = $products[$form_state['values']['attributes']['product_select']];
        }
        else {
          reset($matching_products);
          $default_product = $matching_products[key($matching_products)];
        }
      }

      // Wrap the default product for later use.
      $default_product_wrapper = entity_metadata_wrapper('commerce_product', $default_product);

      $form_state['default_product'] = $default_product;
      $form_state['context'] = $context;

      // If all the products are of the same type...
      if ($same_type) {
        // Loop through all the field instances on that product type.
        foreach (field_info_instances('commerce_product', $type) as $name => $instance) {
          // A field qualifies if it is single value, required and uses a widget
          // with a definite set of options. For the sake of simplicity, this is
          // currently restricted to fields defined by the options module.
          $field = field_info_field($instance['field_name']);

          if ($field['cardinality'] == 1 && $instance['required'] && $instance['widget']['module'] == 'options') {
            // Get the options properties from the options module and store the
            // options for the instance in select list format in the array of
            // qualifying fields.
            $properties = _options_properties('select', FALSE, TRUE, TRUE);

            $qualifying_fields[$name] = array(
              'field' => $field,
              'instance' => $instance,
              'options' => _options_get_options($field, $instance, $properties),
              'weight' => $instance['widget']['weight'],
            );
          }
        }
      }

      // Otherwise for products of varying types, display a simple select list
      // by product title.
      if (!empty($qualifying_fields)) {
        $used_options = array();

        // Sort the fields by weight.
        uasort($qualifying_fields, 'drupal_sort_weight');

        foreach ($qualifying_fields as $field_name => $data) {
          // Build an options array of widget options used by referenced products.
          foreach ($products as $product_id => $product) {
            $product_wrapper = entity_metadata_wrapper('commerce_product', $product);

            // Only add options to the present array that appear on products that
            // match the default value of the previously added attribute widgets.
            foreach ($used_options as $used_field_name => $unused) {
              // Don't apply this check for the current field being evaluated.
              if ($used_field_name == $field_name) {
                continue;
              }

              if ($product_wrapper->{$used_field_name}->value() != $form['attributes'][$used_field_name]['#default_value']) {
                continue 2;
              }
            }

            // With our hard dependency on widgets provided by the Options
            // module, we can make assumptions about where the data is stored.
            $used_options[$field_name][] = $product_wrapper->{$field_name}->value();
          }

          // If for some reason no options for this field are used, remove it
          // from the qualifying fields array.
          if (empty($used_options[$field_name])) {
            unset($qualifying_fields[$field_name]);
          }
          else {
            $form['attributes'][$field_name] = array(
              '#type' => 'select',
              '#title' => check_plain($data['instance']['label']),
              '#options' => array_intersect_key($data['options'], drupal_map_assoc($used_options[$field_name])),
              '#default_value' => $default_product_wrapper->{$field_name}->value(),
              '#weight' => $data['instance']['widget']['weight'],
              '#ajax' => array(
                'callback' => 'commerce_cart_add_to_cart_form_attributes_refresh',
              ),
            );
            $form['unchanged_attributes'][$field_name] = array(
              '#type' => 'value',
              '#value' => $default_product_wrapper->{$field_name}->value(),
            );
          }
        }

        if (!empty($form['attributes'])) {
          $form['attributes'] += array(
            '#tree' => 'TRUE',
            '#prefix' => '<div class="attribute-widgets">',
            '#suffix' => '</div>',
            '#weight' => 0,
          );
          $form['unchanged_attributes'] += array(
            '#tree' => 'TRUE',
          );

          // If the matching products array is empty, it means this is the first
          // time the form is being built. We should populate it now with
          // products that match the default attribute options.
          if (empty($matching_products)) {
            foreach ($products as $product_id => $product) {
              $product_wrapper = entity_metadata_wrapper('commerce_product', $product);
              $match = TRUE;

              foreach (element_children($form['attributes']) as $field_name) {
                if ($product_wrapper->{$field_name}->value() != $form['attributes'][$field_name]['#default_value']) {
                  $match = FALSE;
                }
              }

              if ($match) {
                $matching_products[$product_id] = $product;
              }
            }
          }

          // If there were more than one matching products for the current
          // attribute selection, add a product selection widget.
          if (count($matching_products) > 1) {
            $options = array();

            foreach ($matching_products as $product_id => $product) {
              $options[$product_id] = check_plain($product->title);
            }

            $form['attributes']['product_select'] = array(
              '#type' => 'select',
              '#title' => t('Select a product'),
              '#options' => $options,
              '#default_value' => $default_product->product_id,
              '#weight' => 40,
              '#ajax' => array(
                'callback' => 'commerce_cart_add_to_cart_form_attributes_refresh',
              ),
            );
          }

          $form['product_id'] = array(
            '#type' => 'hidden',
            '#value' => $default_product->product_id,
          );
        }
      }

      // If the products referenced were of different types or did not posess
      // any qualifying attribute fields, add a product selection widget.
      if (!$same_type || empty($qualifying_fields)) {
        $options = array();

        foreach ($products as $product_id => $product) {
          $options[$product_id] = check_plain($product->title);
        }

        $form['product_id'] = array(
          '#type' => 'select',
          '#options' => $options,
          '#default_value' => $default_product->product_id,
          '#weight' => 0,
          '#ajax' => array(
            'callback' => 'commerce_cart_add_to_cart_form_attributes_refresh',
          ),
        );
      }
    }

    // Render the quantity field as either a textfield if shown or a hidden
    // field if not.
    if ($show_quantity) {
      $form['quantity'] = array(
        '#type' => 'textfield',
        '#title' => t('Quantity'),
        '#default_value' => $default_quantity,
        '#datatype' => 'integer',
        '#size' => 5,
        '#weight' => 5,
      );
    }
    else {
      $form['quantity'] = array(
        '#type' => 'hidden',
        '#value' => $default_quantity,
        '#datatype' => 'integer',
        '#weight' => 5,
      );
    }

    $form['display_uri'] = array(
      '#type' => 'value',
      '#value' => $display_uri,
    );

    $form['submit'] = array(
      '#type' => 'submit',
      '#value' => t('Add to cart'),
      '#weight' => 10,
    );
  }

  // Add the handlers manually since we're using hook_forms() to associate this
  // form with form IDs based on the $product_ids.
  $form['#validate'][] = 'commerce_cart_add_to_cart_form_validate';
  $form['#submit'][] = 'commerce_cart_add_to_cart_form_submit';

  return $form;
}

/**
 * Form validate handler: validate the product and quantity to add to the cart.
 */
function commerce_cart_add_to_cart_form_validate($form, &$form_state) {
  if (!is_numeric($form_state['values']['quantity']) || $form_state['values']['quantity'] <= 0) {
    form_set_error('quantity', t('You must specify a valid quantity to add to the cart.'));
  }

  // If the custom data type attribute of the quantity element is integer,
  // ensure we only accept whole number values.
  if ($form['quantity']['#datatype'] == 'integer' &&
    (int) $form_state['values']['quantity'] != $form_state['values']['quantity']) {
    form_set_error('quantity', t('You must specify a whole number for the quantity.'));
  }

  // If the attributes matching product selector was used, set the value of the
  // product_id field to match; this will be fixed on rebuild when the actual
  // default product will be selected based on the product selector value.
  if (!empty($form_state['values']['attributes']['product_select'])) {
    form_set_value($form['product_id'], $form_state['values']['attributes']['product_select'], $form_state);
  }
}

/**
 * Ajax callback: returns AJAX commands when an attribute widget is changed.
 */
function commerce_cart_add_to_cart_form_attributes_refresh($form, $form_state) {
  $commands = array();

  // Render the form afresh to capture any changes to the available widgets
  // based on the latest selection.
  $commands[] = ajax_command_replace('.' . drupal_html_class($form['#form_id']), drupal_render($form));

  // Then render and return the various product fields that might need to be
  // updated on the page.
  if (!empty($form_state['context'])) {
    $product = $form_state['default_product'];

    foreach (field_info_instances('commerce_product', $product->type) as $product_field_name => $product_field) {
      $class = drupal_html_class(implode('-', array($form_state['context']['class_prefix'], 'product', $product_field_name)));

      $element = field_view_field('commerce_product', $product, $product_field_name, $form_state['context']['view_mode']);
      $element += array(
        '#prefix' => '<span class="' . $class . '">',
        '#suffix' => '</span>',
      );

      $commands[] = ajax_command_replace('.' . $class, drupal_render($element));
    }
  }

  return array('#type' => 'ajax', '#commands' => $commands);
}

/**
 * Form submit handler: add the selected product to the cart.
 */
function commerce_cart_add_to_cart_form_submit($form, &$form_state) {
  $product_id = $form_state['values']['product_id'];
  $product = $form_state['products'][$product_id];

  // Add the product to the specified shopping cart.
  $form_state['line_item'] = commerce_cart_product_add(
    $form_state['values']['uid'],
    $product_id,
    $form_state['values']['quantity'],
    $form_state['values']['display_uri']
  );

  // TODO: Accommodate multiple product Add to Cart forms better; i.e. should it
  // display the product title or the product display node title?
  drupal_set_message(t('%title added to <a href="!cart-url">your cart</a>.', array('%title' => $product->title, '!cart-url' => url('cart'))));
}

/**
 * Implements hook_field_info_alter().
 */
function commerce_cart_field_info_alter(&$info) {
  // Set the default display formatter for product reference fields to the Add
  // to Cart form.
  $info['commerce_product_reference']['default_formatter'] = 'commerce_cart_add_to_cart_form';
}

/**
 * Implements hook_field_formatter_info().
 */
function commerce_cart_field_formatter_info() {
  return array(
    'commerce_cart_add_to_cart_form' => array(
      'label' => t('Add to Cart form'),
      'description' => t('Display an Add to Cart form for the referenced product.'),
      'field types' => array('commerce_product_reference'),
      'settings' => array(
        'show_quantity' => FALSE,
        'default_quantity' => 1,
      ),
    ),
  );
}

/**
 * Implements hook_field_formatter_settings_form().
 */
function commerce_cart_field_formatter_settings_form($field, $instance, $view_mode, $form, &$form_state) {
  $display = $instance['display'][$view_mode];
  $settings = $display['settings'];

  $element = array();

  if ($display['type'] == 'commerce_cart_add_to_cart_form') {
    $element['show_quantity'] = array(
      '#type' => 'checkbox',
      '#title' => t('Display a textfield quantity widget on the add to cart form.'),
      '#default_value' => $settings['show_quantity'],
    );

    $element['default_quantity'] = array(
      '#type' => 'textfield',
      '#title' => t('Default quantity'),
      '#default_value' => $settings['default_quantity'] <= 0 ? 1 : $settings['default_quantity'],
      '#element_validate' => array('commerce_cart_field_formatter_settings_form_quantity_validate'),
      '#size' => 16,
    );
  }

  return $element;
}

/**
 * Element validate callback: ensure a valid quantity is entered.
 */
function commerce_cart_field_formatter_settings_form_quantity_validate($element, &$form_state, $form) {
  if (!is_numeric($element['#value']) || $element['#value'] <= 0) {
    form_set_error(implode('][', $element['#parents']), t('You must enter a positive numeric default quantity value.'));
  }
}

/**
 * Implements hook_field_formatter_settings_summary().
 */
function commerce_cart_field_formatter_settings_summary($field, $instance, $view_mode) {
  $display = $instance['display'][$view_mode];
  $settings = $display['settings'];

  $summary = array();

  if ($display['type'] == 'commerce_cart_add_to_cart_form') {
    $summary = array(
      t('Quantity widget: !status', array('!status' => $settings['show_quantity'] ? t('Enabled') : t('Disabled'))),
      t('Default quantity: @quantity', array('@quantity' => $settings['default_quantity'])),
    );
  }

  return implode('<br />', $summary);
}

/**
 * Implements hook_field_formatter_view().
 */
function commerce_cart_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  $result = array();

  // Collect the list of product IDs.
  $product_ids = array();

  foreach ($items as $delta => $item) {
    $product_ids[$item['product_id']] = $item['product_id'];
  }

  if ($display['type'] == 'commerce_cart_add_to_cart_form') {
    $settings = $display['settings'];

    $result[] = array(
      '#arguments' => array(
        'form_id' => commerce_cart_add_to_cart_form_id($product_ids),
        'product_ids' => $product_ids,
        'show_quantity' => $settings['show_quantity'],
        'default_quantity' => $settings['default_quantity'],
      ),
    );
  }

  return $result;
}

/**
 * Implements hook_field_attach_view_alter().
 *
 * When a field is formatted for display, the display formatter does not know
 * what view mode it is being displayed for. Unfortunately, the Add to Cart form
 * display formatter needs this information when displaying product reference
 * fields on nodes to provide adequate context for product field replacement on
 * multi-value product reference fields. This hook is used to transform a set of
 * arguments into a form using the arguments and the extra context information
 * gleaned from the parameters passed into this function.
 */
function commerce_cart_field_attach_view_alter(&$output, $context) {
  // Loop through the fields passed in looking for any product reference fields
  // formatted with the Add to Cart form display formatter.
  foreach ($output as $field_name => $element) {
    if (!empty($element['#formatter']) && $element['#formatter'] == 'commerce_cart_add_to_cart_form') {
      // Prepare the context information needed by the cart form.
      $context = array();
      $display_uri = NULL;

      // Add the context for displaying product fields in the context of a node
      // that references the product by looking at the entity this product
      // reference field is attached to.
      if ($element['#entity_type'] == 'node') {
        $context = array(
          'class_prefix' => 'node-' . $element['#object']->nid,
          'view_mode' => 'node_' . $element['#view_mode'],
        );

        $display_uri = entity_uri('node', $element['#object']);
      }

      foreach (element_children($element) as $key) {
        // Extract the drupal_get_form() arguments array from the element.
        $arguments = $element[$key]['#arguments'];

        // Replace the array containing the arguments with the return value of
        // drupal_get_form(). It will be rendered when the rest of the object is
        // rendered for display.
        $output[$field_name][$key] = drupal_get_form($arguments['form_id'], $arguments['product_ids'], $arguments['show_quantity'], $arguments['default_quantity'], $context, $display_uri);
      }
    }
  }
}
